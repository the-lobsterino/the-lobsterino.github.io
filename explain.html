<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéì Shader Explainer - Clawd</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Outfit:wght@300;600;900&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --neon-pink: #ff2d95;
      --neon-cyan: #00f5ff;
      --neon-purple: #b537f2;
      --neon-green: #39ff14;
      --neon-orange: #ff9500;
      --dark: #0a0a0f;
      --darker: #050508;
      --glass: rgba(255,255,255,0.05);
    }
    
    body {
      font-family: 'Outfit', sans-serif;
      background: var(--dark);
      color: #fff;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    /* Background */
    .bg-gradient {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, var(--dark) 0%, #1a0a2e 50%, var(--dark) 100%);
      z-index: -2;
    }
    
    /* Header */
    header {
      padding: 1rem 2rem;
      background: var(--darker);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 1rem;
      text-decoration: none;
      color: #fff;
    }
    
    .logo span {
      font-size: 2rem;
    }
    
    .logo h1 {
      font-size: 1.5rem;
      background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .shader-select {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .shader-select label {
      font-family: 'Space Mono', monospace;
      font-size: 0.9rem;
      color: var(--neon-cyan);
    }
    
    .shader-select select {
      padding: 0.75rem 1.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid var(--neon-purple);
      border-radius: 8px;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 0.9rem;
      cursor: pointer;
      min-width: 200px;
    }
    
    .shader-select select:focus {
      outline: none;
      box-shadow: 0 0 20px rgba(181, 55, 242, 0.5);
    }
    
    /* Main layout */
    main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      min-height: calc(100vh - 70px);
    }
    
    @media (max-width: 1024px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    
    /* Shader preview panel */
    .preview-panel {
      background: var(--darker);
      padding: 2rem;
      display: flex;
      flex-direction: column;
      border-right: 1px solid rgba(255,255,255,0.1);
    }
    
    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .preview-header h2 {
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .char-count {
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      color: var(--neon-green);
      padding: 0.25rem 0.75rem;
      background: rgba(57, 255, 20, 0.1);
      border-radius: 20px;
    }
    
    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 300px;
    }
    
    #preview-canvas {
      width: 100%;
      max-width: 500px;
      aspect-ratio: 16/10;
      border-radius: 12px;
      border: 2px solid var(--neon-purple);
      box-shadow: 0 0 40px rgba(181, 55, 242, 0.3);
    }
    
    .controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .control-btn {
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: 1px solid var(--neon-cyan);
      border-radius: 8px;
      color: var(--neon-cyan);
      font-family: 'Space Mono', monospace;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .control-btn:hover {
      background: var(--neon-cyan);
      color: var(--dark);
    }
    
    .control-btn.active {
      background: var(--neon-cyan);
      color: var(--dark);
    }
    
    /* Code panel */
    .code-panel {
      padding: 2rem;
      overflow-y: auto;
      max-height: calc(100vh - 70px);
    }
    
    .code-section {
      margin-bottom: 2rem;
    }
    
    .section-title {
      font-size: 1.2rem;
      color: var(--neon-pink);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    /* Code display */
    .code-block {
      background: var(--darker);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 1rem;
    }
    
    .code-header {
      padding: 0.75rem 1rem;
      background: rgba(255,255,255,0.05);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      color: var(--neon-cyan);
      display: flex;
      justify-content: space-between;
    }
    
    .code-content {
      padding: 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      overflow-x: auto;
    }
    
    .code-content pre {
      margin: 0;
      white-space: pre-wrap;
    }
    
    /* Syntax highlighting */
    .keyword { color: var(--neon-pink); }
    .type { color: var(--neon-cyan); }
    .number { color: var(--neon-green); }
    .function { color: var(--neon-orange); }
    .comment { color: #666; font-style: italic; }
    .string { color: #98c379; }
    .operator { color: #fff; }
    
    /* Annotations */
    .annotation {
      background: rgba(181, 55, 242, 0.1);
      border-left: 3px solid var(--neon-purple);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }
    
    .annotation-title {
      font-weight: 600;
      color: var(--neon-purple);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .annotation-content {
      font-size: 0.95rem;
      line-height: 1.7;
      opacity: 0.9;
    }
    
    .annotation-content code {
      background: rgba(255,255,255,0.1);
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      font-family: 'Space Mono', monospace;
      font-size: 0.85rem;
      color: var(--neon-cyan);
    }
    
    /* Concept cards */
    .concept-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .concept-card {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 1rem;
      transition: transform 0.3s;
    }
    
    .concept-card:hover {
      transform: translateY(-3px);
    }
    
    .concept-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }
    
    .concept-name {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    
    .concept-desc {
      font-size: 0.85rem;
      opacity: 0.7;
    }
    
    /* Visual diagrams */
    .diagram {
      background: var(--darker);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .diagram-title {
      font-size: 0.9rem;
      color: var(--neon-cyan);
      margin-bottom: 1rem;
      text-align: center;
    }
    
    .diagram svg {
      width: 100%;
      max-width: 400px;
      display: block;
      margin: 0 auto;
    }
    
    /* Coordinate system diagram */
    .coord-diagram {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    .coord-grid {
      width: 200px;
      height: 200px;
      background: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
      background-size: 25px 25px;
      border: 2px solid var(--neon-cyan);
      border-radius: 8px;
      position: relative;
    }
    
    .coord-label {
      position: absolute;
      font-family: 'Space Mono', monospace;
      font-size: 0.7rem;
      color: var(--neon-cyan);
    }
    
    .coord-origin { bottom: -20px; left: -5px; }
    .coord-x { bottom: -20px; right: -25px; color: var(--neon-pink); }
    .coord-y { top: -20px; left: -5px; color: var(--neon-green); }
    
    .pixel-dot {
      width: 10px;
      height: 10px;
      background: var(--neon-pink);
      border-radius: 50%;
      position: absolute;
      animation: pixelPulse 2s ease-in-out infinite;
    }
    
    @keyframes pixelPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.7; }
    }
    
    /* Math formulas */
    .formula {
      background: rgba(0, 245, 255, 0.1);
      border: 1px solid var(--neon-cyan);
      border-radius: 8px;
      padding: 1rem;
      margin: 0.5rem 0;
      font-family: 'Space Mono', monospace;
      text-align: center;
      font-size: 1.1rem;
    }
    
    /* Step indicators */
    .step {
      display: flex;
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .step-number {
      width: 32px;
      height: 32px;
      background: var(--neon-pink);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: var(--dark);
      flex-shrink: 0;
    }
    
    .step-content {
      flex: 1;
    }
    
    .step-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .step-desc {
      opacity: 0.8;
      line-height: 1.7;
    }
    
    /* Twigl reference */
    .twigl-ref {
      background: linear-gradient(135deg, rgba(181, 55, 242, 0.2), rgba(255, 45, 149, 0.2));
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    
    .twigl-ref h3 {
      color: var(--neon-pink);
      margin-bottom: 1rem;
    }
    
    .twigl-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .twigl-table th, .twigl-table td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .twigl-table th {
      color: var(--neon-cyan);
      font-family: 'Space Mono', monospace;
    }
    
    .twigl-table code {
      background: rgba(255,255,255,0.1);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: 'Space Mono', monospace;
      color: var(--neon-green);
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--darker);
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--neon-purple);
      border-radius: 4px;
    }
    
    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--neon-cyan);
    }
    
    .loading::after {
      content: '';
      width: 30px;
      height: 30px;
      border: 3px solid transparent;
      border-top-color: var(--neon-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 1rem;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="bg-gradient"></div>
  
  <header>
    <a href="index.html" class="logo">
      <span>üêæ</span>
      <h1>Shader Explainer</h1>
    </a>
    <div class="shader-select">
      <label for="shader-dropdown">Choose shader:</label>
      <select id="shader-dropdown">
        <option value="">Loading...</option>
      </select>
    </div>
  </header>
  
  <main>
    <div class="preview-panel">
      <div class="preview-header">
        <h2>‚ú® <span id="shader-title">Select a Shader</span></h2>
        <span class="char-count" id="char-count">0 chars</span>
      </div>
      <div class="canvas-container">
        <canvas id="preview-canvas" width="500" height="312"></canvas>
      </div>
      <div class="controls">
        <button class="control-btn active" id="play-btn">‚ñ∂ Play</button>
        <button class="control-btn" id="pause-btn">‚è∏ Pause</button>
        <button class="control-btn" id="reset-btn">‚Ü∫ Reset</button>
      </div>
    </div>
    
    <div class="code-panel" id="code-panel">
      <!-- Intro section always visible -->
      <div class="twigl-ref">
        <h3>üìñ Twigl Format Reference</h3>
        <p style="margin-bottom: 1rem; opacity: 0.8;">These tweet-sized shaders use a compact format. Here's how to read them:</p>
        <table class="twigl-table">
          <tr><th>Symbol</th><th>Standard GLSL</th><th>Meaning</th></tr>
          <tr><td><code>t</code></td><td>time</td><td>Time in seconds since start</td></tr>
          <tr><td><code>r</code></td><td>resolution</td><td>Screen size in pixels (vec2)</td></tr>
          <tr><td><code>FC</code></td><td>gl_FragCoord</td><td>Current pixel position</td></tr>
          <tr><td><code>o</code></td><td>gl_FragColor</td><td>Output color (vec4: RGBA)</td></tr>
          <tr><td><code>m</code></td><td>mouse</td><td>Mouse position (0-1)</td></tr>
        </table>
      </div>
      
      <div id="explanation-content">
        <div class="loading">Loading shader explanation</div>
      </div>
    </div>
  </main>
  
  <script>
    // ==========================================
    // SHADER DEFINITIONS WITH EXPLANATIONS
    // ==========================================
    
    const EXPLAINED_SHADERS = {
      'whirl': {
        name: 'Whirl',
        author: '@XorDev',
        category: 'abstract',
        chars: 247,
        code: `for(float i=0.,z=0.,d=0.,h=0.;i<80.;i++){
  vec3 p=z*normalize(vec3(FC.xy*2.-r,r.y));
  p.z+=9.;
  vec3 a=vec3(.5);
  a=mix(dot(a,p)*a,p,sin(h=dot(p,p/p)-t))+cos(h)*cross(a,p);
  for(d=0.;d<9.;d++)a+=.3*sin(a*d).zxy;
  z+=d=length(a.xz)/15.;
  o+=vec4(9,5,h+t,1)/d;
}
o=tanh(o/1e4);`,
        steps: [
          {
            title: 'Raymarching Setup',
            code: 'for(float i=0.,z=0.,d=0.,h=0.;i<80.;i++)',
            explanation: 'This sets up a raymarching loop that runs 80 times. Variables: <code>i</code> = iteration counter, <code>z</code> = distance traveled along ray, <code>d</code> = step distance, <code>h</code> = helper variable for animation.'
          },
          {
            title: 'Ray Direction',
            code: 'vec3 p=z*normalize(vec3(FC.xy*2.-r,r.y))',
            explanation: 'Calculates the 3D position by: 1) Converting pixel coords to centered UV (-1 to 1), 2) Creating a ray direction with the screen as XY and depth as Z, 3) Multiplying by distance <code>z</code> to march along the ray.'
          },
          {
            title: 'The Twist Magic',
            code: 'a=mix(dot(a,p)*a,p,sin(h=dot(p,p/p)-t))+cos(h)*cross(a,p)',
            explanation: 'This creates the swirling motion using: <code>mix()</code> blends between two vectors based on time, <code>cross()</code> creates perpendicular motion, <code>sin()</code> and <code>cos()</code> create the rotation. The <code>-t</code> makes it animate!'
          },
          {
            title: 'Fractal Detail',
            code: 'for(d=0.;d<9.;d++)a+=.3*sin(a*d).zxy',
            explanation: 'Adds 9 layers of sine-based detail. Each iteration: adds higher frequency waves (<code>a*d</code>), swizzles components (<code>.zxy</code>) for interesting patterns, scales by 0.3 to prevent explosion.'
          },
          {
            title: 'Color Accumulation',
            code: 'o+=vec4(9,5,h+t,1)/d',
            explanation: 'Accumulates color per step. Dividing by <code>d</code> (distance) makes closer surfaces brighter. The <code>vec4(9,5,h+t,1)</code> creates warm colors that shift with time.'
          },
          {
            title: 'Final Tone Mapping',
            code: 'o=tanh(o/1e4)',
            explanation: '<code>tanh()</code> is a smooth S-curve that compresses the accumulated brightness into 0-1 range. Dividing by 10000 first prevents oversaturation. This is a common HDR technique!'
          }
        ],
        concepts: [
          { icon: 'üéØ', name: 'Raymarching', desc: 'Stepping through 3D space along rays' },
          { icon: 'üåÄ', name: 'Cross Product', desc: 'Creates perpendicular rotation axes' },
          { icon: 'üìä', name: 'tanh()', desc: 'Smooth tone mapping function' }
        ]
      },
      
      'artifacts': {
        name: 'Artifacts',
        author: '@XorDev',
        category: 'abstract',
        chars: 168,
        code: `for(float i=0.,z=0.,d=0.;i<77.;i++){
  vec3 p=z*normalize(vec3(FC.xy*2.-r,r.y));
  p.xy+=t;
  for(d=0.;d<9.;d++)p+=sin(round(p)+d*3.).zxy;
  z+=d=abs(p.z/30.+.2);
  o+=vec4(z,z,9,1)/d;
}
o=tanh(o/8e4);`,
        steps: [
          {
            title: 'Simple Ray Setup',
            code: 'vec3 p=z*normalize(vec3(FC.xy*2.-r,r.y))',
            explanation: 'Creates a ray from the camera through each pixel. The normalize ensures the ray has unit length, then we scale by <code>z</code> to get the current position along the ray.'
          },
          {
            title: 'Time Movement',
            code: 'p.xy+=t',
            explanation: 'Simply adds time to the X and Y coordinates. This makes the entire scene scroll diagonally, creating the "flying through space" effect.'
          },
          {
            title: 'The Magic Loop',
            code: 'for(d=0.;d<9.;d++)p+=sin(round(p)+d*3.).zxy',
            explanation: 'This is the heart of the effect! <code>round(p)</code> snaps to grid points, <code>sin()</code> creates waves, <code>.zxy</code> swizzles components to create 3D patterns. Each iteration adds more complexity.'
          },
          {
            title: 'Distance Estimation',
            code: 'z+=d=abs(p.z/30.+.2)',
            explanation: 'A simple distance estimate based on Z depth. The <code>abs()</code> creates the crystalline structure. The constants control how chunky vs smooth the result looks.'
          },
          {
            title: 'Color Output',
            code: 'o+=vec4(z,z,9,1)/d',
            explanation: 'Accumulates a bluish color (note the 9 in blue channel). Dividing by distance <code>d</code> makes nearby surfaces bright. Using <code>z</code> for red/green creates depth-based color variation.'
          }
        ],
        concepts: [
          { icon: 'üî≤', name: 'round()', desc: 'Snaps values to create grid patterns' },
          { icon: 'üîÑ', name: 'Swizzling', desc: '.zxy rotates vector components' },
          { icon: 'üíé', name: 'abs()', desc: 'Creates mirror symmetry' }
        ]
      },
      
      'plasma': {
        name: 'Classic Plasma',
        author: 'demo scene',
        category: 'abstract',
        chars: 180,
        code: `vec2 uv = FC.xy/r;
float v = sin(uv.x*10.+t);
v += sin(uv.y*10.+t);
v += sin((uv.x+uv.y)*10.+t);
v += sin(length(uv-0.5)*20.-t*2.);
v = v/4.*.5+.5;
o = vec4(v,v*.3,v*.8,1);`,
        steps: [
          {
            title: 'Normalize Coordinates',
            code: 'vec2 uv = FC.xy/r',
            explanation: 'Converts pixel coordinates to 0-1 range. <code>FC.xy</code> is the pixel position (e.g., 0-800), dividing by resolution <code>r</code> normalizes to 0-1.'
          },
          {
            title: 'Horizontal Waves',
            code: 'float v = sin(uv.x*10.+t)',
            explanation: 'Creates vertical stripes that move horizontally. <code>uv.x*10</code> = 10 waves across screen, <code>+t</code> = animate over time. <code>sin()</code> oscillates -1 to 1.'
          },
          {
            title: 'Vertical Waves',
            code: 'v += sin(uv.y*10.+t)',
            explanation: 'Adds horizontal stripes. When combined with the X waves, you get a grid-like interference pattern.'
          },
          {
            title: 'Diagonal Waves',
            code: 'v += sin((uv.x+uv.y)*10.+t)',
            explanation: 'Adds 45¬∞ diagonal waves. The sum <code>uv.x+uv.y</code> creates lines where x+y is constant (diagonals).'
          },
          {
            title: 'Circular Waves',
            code: 'v += sin(length(uv-0.5)*20.-t*2.)',
            explanation: '<code>length(uv-0.5)</code> = distance from center, creating expanding circles. <code>-t*2</code> makes them expand outward (negative = opposite direction).'
          },
          {
            title: 'Normalize & Color',
            code: 'v = v/4.*.5+.5; o = vec4(v,v*.3,v*.8,1)',
            explanation: 'Divides by 4 (number of waves added), then maps from -0.5..0.5 to 0..1. The color multipliers create a purple-ish palette.'
          }
        ],
        concepts: [
          { icon: 'üåä', name: 'sin()', desc: 'Creates smooth wave patterns' },
          { icon: 'üìè', name: 'length()', desc: 'Distance for circular effects' },
          { icon: '‚ûï', name: 'Wave Addition', desc: 'Combine waves for interference' }
        ]
      },
      
      'tunnel': {
        name: 'Tunnel',
        author: 'classic',
        category: 'geometric',
        chars: 150,
        code: `vec2 uv = (FC.xy-.5*r)/r.y;
float a = atan(uv.y,uv.x);
float l = 1./length(uv);
float v = sin(a*8.+l*2.-t*3.)*sin(l-t);
o = vec4(vec3(v*.5+.5)*vec3(.8,.2,.6),1);`,
        steps: [
          {
            title: 'Center & Normalize',
            code: 'vec2 uv = (FC.xy-.5*r)/r.y',
            explanation: '<code>-.5*r</code> centers the origin (0,0 at screen center). Dividing by <code>r.y</code> (height) maintains aspect ratio. Now uv ranges from about -0.8 to 0.8.'
          },
          {
            title: 'Get Angle',
            code: 'float a = atan(uv.y,uv.x)',
            explanation: '<code>atan(y,x)</code> returns the angle in radians from the positive X axis. This converts from Cartesian (x,y) to polar (angle, radius) coordinates.'
          },
          {
            title: 'Tunnel Depth',
            code: 'float l = 1./length(uv)',
            explanation: 'The inverse of distance from center. Near the center, <code>length</code> is small, so <code>1/length</code> is large = "far away" in the tunnel. Creates the infinite depth illusion!'
          },
          {
            title: 'Pattern Formula',
            code: 'float v = sin(a*8.+l*2.-t*3.)*sin(l-t)',
            explanation: '<code>a*8</code> = 8 segments around the tunnel. <code>l*2</code> = rings going into depth. <code>-t*3</code> = fast animation. The second <code>sin(l-t)</code> adds pulsing waves.'
          },
          {
            title: 'Color Mapping',
            code: 'o = vec4(vec3(v*.5+.5)*vec3(.8,.2,.6),1)',
            explanation: '<code>v*.5+.5</code> maps -1..1 to 0..1. Multiplying by <code>vec3(.8,.2,.6)</code> tints it pink/purple.'
          }
        ],
        concepts: [
          { icon: 'üéØ', name: 'Polar Coords', desc: 'atan() for angle, length() for radius' },
          { icon: '‚ôæÔ∏è', name: '1/distance', desc: 'Creates infinite depth illusion' },
          { icon: 'üîÑ', name: 'Radial Pattern', desc: 'sin(angle*N) for N-fold symmetry' }
        ]
      },
      
      'matrix': {
        name: 'Digital Rain',
        author: '@XorDev',
        category: 'psychedelic',
        chars: 175,
        code: `vec2 uv = FC.xy/r;
vec2 grid = floor(uv*vec2(30,20));
float rnd = fract(sin(dot(grid,vec2(12.98,78.23)))*43758.);
float drop = fract(rnd*10.-t*(.5+rnd));
float bright = smoothstep(1.,0.,drop)*step(.8,rnd);
o = vec4(0,bright,bright*.3,1);`,
        steps: [
          {
            title: 'Create Grid',
            code: 'vec2 grid = floor(uv*vec2(30,20))',
            explanation: 'Multiplying by (30,20) creates that many cells, then <code>floor()</code> snaps to integer cell IDs. Each cell will have the same value, creating the blocky effect.'
          },
          {
            title: 'Random Per Cell',
            code: 'float rnd = fract(sin(dot(grid,vec2(12.98,78.23)))*43758.)',
            explanation: 'The classic "hash" function! <code>dot()</code> combines x,y into one number, <code>sin()</code> scrambles it, large multiply spreads values, <code>fract()</code> keeps only 0-1. Each cell gets unique random.'
          },
          {
            title: 'Falling Animation',
            code: 'float drop = fract(rnd*10.-t*(.5+rnd))',
            explanation: '<code>-t</code> makes it fall over time. <code>*(.5+rnd)</code> = random speeds per column. <code>rnd*10</code> = random start offsets. <code>fract()</code> = loop 0-1.'
          },
          {
            title: 'Brightness Falloff',
            code: 'float bright = smoothstep(1.,0.,drop)*step(.8,rnd)',
            explanation: '<code>smoothstep(1,0,drop)</code> = brightest at drop=0, fades to drop=1 (the trail). <code>step(.8,rnd)</code> = only 20% of columns are active (sparse rain).'
          },
          {
            title: 'Green Glow',
            code: 'o = vec4(0,bright,bright*.3,1)',
            explanation: 'Classic Matrix green! Full brightness in green channel, slight amount in blue (<code>*.3</code>) for that cyan-ish glow.'
          }
        ],
        concepts: [
          { icon: 'üé≤', name: 'Hash Function', desc: 'sin(dot())*big for pseudo-random' },
          { icon: 'üì¶', name: 'floor()', desc: 'Creates discrete grid cells' },
          { icon: '‚ú®', name: 'smoothstep()', desc: 'Smooth fade between values' }
        ]
      },
      
      'fire': {
        name: 'Fire',
        author: '@XorDev',
        category: 'nature',
        chars: 185,
        code: `vec2 uv = FC.xy/r;
uv.y = 1.-uv.y;
float n = 0.;
for(float i=1.;i<5.;i++){
  n += snoise2D(vec2(uv.x*i*3.,uv.y*i*2.-t*i))/i;
}
n = n*.5+.5;
n *= 1.-uv.y;
vec3 c = mix(vec3(1,.2,0),vec3(1,1,0),n);
c = mix(vec3(0),c,smoothstep(0.,.5,n));
o = vec4(c,1);`,
        steps: [
          {
            title: 'Flip Y Axis',
            code: 'uv.y = 1.-uv.y',
            explanation: 'Fire rises up, so we flip Y so that y=0 is at the bottom. Now the "ground" is at the bottom of the screen.'
          },
          {
            title: 'Layered Noise',
            code: 'for(float i=1.;i<5.;i++) n += snoise2D(...)/i',
            explanation: 'Adds 4 layers of Simplex noise. Each layer: higher frequency (<code>*i*3</code>), different scroll speed (<code>-t*i</code>), lower amplitude (<code>/i</code>). This is called "fractal Brownian motion" (fBm).'
          },
          {
            title: 'Upward Motion',
            code: 'uv.y*i*2.-t*i',
            explanation: 'The <code>-t*i</code> makes noise scroll upward over time. Higher layers (<code>*i</code>) scroll faster, creating the turbulent flickering effect.'
          },
          {
            title: 'Fade at Top',
            code: 'n *= 1.-uv.y',
            explanation: 'Multiplies by inverse Y, so fire fades out toward the top. At bottom (y=0), full intensity. At top (y=1), zero.'
          },
          {
            title: 'Fire Colors',
            code: 'vec3 c = mix(vec3(1,.2,0),vec3(1,1,0),n)',
            explanation: '<code>mix()</code> blends between orange <code>(1,.2,0)</code> and yellow <code>(1,1,0)</code> based on noise intensity. Hotter = yellower.'
          },
          {
            title: 'Black Background',
            code: 'c = mix(vec3(0),c,smoothstep(0.,.5,n))',
            explanation: 'Blends to black where noise is low. <code>smoothstep</code> creates a soft threshold - values below 0.5 fade to black.'
          }
        ],
        concepts: [
          { icon: 'üî•', name: 'fBm Noise', desc: 'Layered noise for natural look' },
          { icon: '‚¨ÜÔ∏è', name: 'UV Animation', desc: 'Subtract time for upward motion' },
          { icon: 'üé®', name: 'mix()', desc: 'Blend between two colors' }
        ]
      },
      
      'mandelbrot': {
        name: 'Mandelbrot Zoom',
        author: 'fractal',
        category: 'psychedelic',
        chars: 210,
        code: `float zoom = pow(2.,mod(t*.5,10.));
vec2 c = (FC.xy*2.-r)/r.y/zoom+vec2(-.745,.186);
vec2 z = vec2(0);
float i;
for(i=0.;i<100.;i++){
  z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c;
  if(dot(z,z)>4.)break;
}
float v = i/100.;
o = vec4(hsv(v+t*.1,.8,v<1.?.9:0.),1);`,
        steps: [
          {
            title: 'Zoom Factor',
            code: 'float zoom = pow(2.,mod(t*.5,10.))',
            explanation: '<code>mod(t*.5,10)</code> cycles 0-10 over 20 seconds. <code>pow(2,x)</code> = exponential zoom: 1x to 1024x magnification, then loops!'
          },
          {
            title: 'Complex Coordinates',
            code: 'vec2 c = (FC.xy*2.-r)/r.y/zoom+vec2(-.745,.186)',
            explanation: 'Centers and scales coordinates, then zooms in. The <code>+vec2(-.745,.186)</code> offsets to a beautiful spiral region of the Mandelbrot set.'
          },
          {
            title: 'The Mandelbrot Formula',
            code: 'z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c',
            explanation: 'This IS the Mandelbrot set! In complex numbers: z = z¬≤ + c. The vec2 represents complex numbers where x=real, y=imaginary. The formula expands to: real = x¬≤-y¬≤, imag = 2xy.'
          },
          {
            title: 'Escape Check',
            code: 'if(dot(z,z)>4.)break',
            explanation: '<code>dot(z,z)</code> = x¬≤ + y¬≤ = |z|¬≤ (magnitude squared). If it exceeds 4, the point "escapes" to infinity - it\'s NOT in the Mandelbrot set. The iteration count when it escapes determines the color.'
          },
          {
            title: 'Coloring',
            code: 'o = vec4(hsv(v+t*.1,.8,v<1.?.9:0.),1)',
            explanation: 'Points that escape get colored by iteration count (v). <code>v<1</code> means it never escaped in 100 iterations = inside the set = black. The <code>+t*.1</code> slowly rotates the color palette.'
          }
        ],
        concepts: [
          { icon: 'üåÄ', name: 'Complex Iteration', desc: 'z = z¬≤ + c repeated' },
          { icon: 'üîç', name: 'Exponential Zoom', desc: 'pow(2,t) for smooth zoom' },
          { icon: 'üé®', name: 'Escape Time', desc: 'Color by iteration count' }
        ]
      },
      
      'galaxy': {
        name: 'Galaxy',
        author: '@XorDev',
        category: 'nature',
        chars: 197,
        code: `vec2 uv = (FC.xy*2.-r)/r.y;
float a = atan(uv.y,uv.x);
float l = length(uv);
float spiral = sin(a*3.+l*10.-t*2.+snoise2D(uv*2.+t*.1)*2.);
spiral *= exp(-l*1.5);
float stars = step(.98,snoise2D(FC.xy*.1));
o.rgb = vec3(.1,.1,.2)+spiral*vec3(.5,.3,.8)+stars;
o.a = 1.;`,
        steps: [
          {
            title: 'Polar Conversion',
            code: 'float a = atan(uv.y,uv.x); float l = length(uv)',
            explanation: 'Converts to polar coordinates. <code>a</code> = angle (0 to 2œÄ around), <code>l</code> = distance from center. Perfect for spiral patterns!'
          },
          {
            title: 'Spiral Arms',
            code: 'sin(a*3.+l*10.-t*2.+...)',
            explanation: '<code>a*3</code> = 3 spiral arms. <code>l*10</code> = arms curve outward (Archimedean spiral). <code>-t*2</code> = rotation animation. The noise adds organic wobble.'
          },
          {
            title: 'Brightness Falloff',
            code: 'spiral *= exp(-l*1.5)',
            explanation: '<code>exp(-l)</code> is exponential decay - bright at center, fading outward. This gives the galaxy its core glow.'
          },
          {
            title: 'Star Field',
            code: 'float stars = step(.98,snoise2D(FC.xy*.1))',
            explanation: '<code>step(.98,noise)</code> = 1 only where noise > 0.98 (about 2% of pixels). Creates random sparse dots = stars!'
          },
          {
            title: 'Final Composite',
            code: 'o.rgb = vec3(.1,.1,.2)+spiral*vec3(.5,.3,.8)+stars',
            explanation: 'Dark blue background + purple spiral arms + white stars. Simple additive blending creates the cosmic look.'
          }
        ],
        concepts: [
          { icon: 'üåÄ', name: 'Spiral Equation', desc: 'angle + radius for spirals' },
          { icon: 'üìâ', name: 'exp() Falloff', desc: 'Natural light decay' },
          { icon: '‚≠ê', name: 'step() Threshold', desc: 'Create sparse points' }
        ]
      }
    };
    
    // Add remaining shaders with basic explanations
    const BASIC_SHADERS = {
      'aurora': {
        name: 'Aurora',
        author: '@XorDev',
        category: 'abstract',
        chars: 196,
        code: `vec2 uv = (FC.xy*2.-r)/r.y;
float a = atan(uv.y,uv.x);
for(float i=0.;i<8.;i++){
  float f = sin(a*3.+t+i)*.5+.5;
  f *= exp(-length(uv)*(.5+i*.1));
  vec3 c = .5+.5*cos(6.28*(i*.1+vec3(0,.33,.67)));
  o.rgb += c*f*.3;
}
o.a = 1.;`,
        steps: [
          { title: 'Layered Colors', code: 'for(float i=0.;i<8.;i++)', explanation: '8 layers of aurora bands, each with different colors and phases.' },
          { title: 'Wave Pattern', code: 'sin(a*3.+t+i)*.5+.5', explanation: 'Sine wave based on angle creates wavy bands that animate with time.' },
          { title: 'Color Cycling', code: '.5+.5*cos(6.28*(i*.1+vec3(0,.33,.67)))', explanation: 'Creates RGB colors offset by 120¬∞ for rainbow effect.' }
        ],
        concepts: [
          { icon: 'üåà', name: 'Color Cycling', desc: 'cos() with offset phases' },
          { icon: 'üìö', name: 'Layer Stacking', desc: 'Multiple passes for depth' }
        ]
      },
      'voxel': {
        name: 'Voxel Raytracer',
        author: '@XorDev',
        category: '3d',
        chars: 175,
        code: `vec3 p=vec3(t*.1,cos(t+r.xy*.01)),d=normalize(vec3((FC.xy-.5*r)/r.y,1));
// DDA voxel traversal
vec3 a,b;
for(float i=0.;i<900.;i++){
  // ... voxel intersection logic
}
o.rgb=fwidth(p+p);o.a=1.;`,
        steps: [
          { title: 'DDA Algorithm', code: 'Digital Differential Analyzer', explanation: 'A classic algorithm for efficiently traversing a 3D voxel grid along a ray. Used in games like Minecraft!' },
          { title: 'Edge Detection', code: 'fwidth(p+p)', explanation: 'fwidth() detects where values change rapidly = edges between voxels. Creates the line art look.' }
        ],
        concepts: [
          { icon: 'üßä', name: 'Voxels', desc: '3D pixels in a grid' },
          { icon: 'üìê', name: 'DDA', desc: 'Efficient grid traversal' }
        ]
      },
      'fractal3d': {
        name: '3D Fractal',
        author: '@XorDev',
        category: '3d',
        chars: 220,
        code: `vec3 ro = vec3(0,0,-3);
vec3 rd = normalize(vec3((FC.xy*2.-r)/r.y, 1));
// Raymarching with folding operations
for(int i=0;i<64;i++){
  vec3 p = ro + rd*d;
  // Fold space for fractal
  for(int j=0;j<4;j++){p=abs(p)-1.;p.xy*=mat2(.8,.6,-.6,.8);}
}`,
        steps: [
          { title: 'Space Folding', code: 'p=abs(p)-1.', explanation: 'abs() mirrors space, -1 shifts it. Repeated folding creates infinite fractal detail!' },
          { title: 'Rotation', code: 'p.xy*=mat2(.8,.6,-.6,.8)', explanation: 'Rotates between folds to create more complex patterns.' }
        ],
        concepts: [
          { icon: 'üîÄ', name: 'Folding', desc: 'abs() creates symmetry' },
          { icon: '‚ôæÔ∏è', name: 'Iteration', desc: 'Repeat for infinite detail' }
        ]
      },
      'spheres': {
        name: 'Infinite Spheres',
        author: '@XorDev',
        category: '3d',
        chars: 190,
        code: `vec3 rd = normalize(vec3((FC.xy*2.-r)/r.y,1));
vec3 ro = vec3(t*.5,t*.3,t);
float d = 0.;
for(int i=0;i<50;i++){
  vec3 p = ro+rd*d;
  p = mod(p,4.)-2.;  // Infinite repetition!
  float h = length(p)-.8;
  d += h*.5;
}`,
        steps: [
          { title: 'Infinite Repetition', code: 'p = mod(p,4.)-2.', explanation: 'mod() wraps coordinates, creating infinite copies. -2 centers each cell. One sphere becomes infinite!' },
          { title: 'Sphere SDF', code: 'length(p)-.8', explanation: 'Distance to sphere surface = distance to center minus radius. Signed Distance Field basics!' }
        ],
        concepts: [
          { icon: 'üîÅ', name: 'mod() Tiling', desc: 'Infinite repetition of space' },
          { icon: '‚≠ï', name: 'Sphere SDF', desc: 'length(p) - radius' }
        ]
      },
      'terrain': {
        name: 'Terrain March',
        author: '@XorDev',
        category: '3d',
        chars: 230,
        code: `vec3 d=vec3(FC.xy*2.-r,r)/r.x,p=vec3(0);
for(float i=0.,s=0.;i<200.;i++){
  s=exp(mod(i,5.));
  float h = p.y+.2-.2*snoise2D((p.xz*.6+t*.2)*s);
  p+=d*h/s;
}
o.grb=.5*d+...;`,
        steps: [
          { title: 'Heightfield Marching', code: 'p.y - noise(p.xz)', explanation: 'Instead of SDFs, we check if we are above/below a noise-based height. Simple but effective terrain!' },
          { title: 'Multi-scale Noise', code: 's=exp(mod(i,5.))', explanation: 'Cycles through different noise scales for varied detail at different distances.' }
        ],
        concepts: [
          { icon: '‚õ∞Ô∏è', name: 'Heightfield', desc: '2D noise as terrain height' },
          { icon: 'üéöÔ∏è', name: 'LOD', desc: 'Level of detail scaling' }
        ]
      },
      'ocean': {
        name: 'Ocean Waves',
        author: '@XorDev',
        category: 'nature',
        chars: 210,
        code: `vec2 uv = (FC.xy*2.-r)/r.y;
float w = 0.;
for(float i=1.;i<6.;i++){
  w += sin(uv.x*i*3.+t*i*.5+snoise2D(uv*i))*(.5/i);
  w += sin(uv.y*i*2.+t*i*.3)*(.3/i);
}
// Horizon blend...`,
        steps: [
          { title: 'Gerstner-like Waves', code: 'sin(uv.x*i*3.+t*i*.5)', explanation: 'Multiple sine waves at different frequencies and speeds simulate ocean surface.' },
          { title: 'Amplitude Scaling', code: '(.5/i)', explanation: 'Higher frequencies have smaller amplitude - just like real ocean waves!' }
        ],
        concepts: [
          { icon: 'üåä', name: 'Wave Synthesis', desc: 'Sum of sines at different frequencies' },
          { icon: 'üåÖ', name: 'Horizon', desc: 'smoothstep() for sky blend' }
        ]
      },
      'clouds': {
        name: 'Volumetric Clouds',
        author: '@XorDev',
        category: 'nature',
        chars: 240,
        code: `vec3 rd = normalize(vec3((FC.xy*2.-r)/r.y,.8));
vec3 ro = vec3(t*.1,1,0);
float d = 0., density = 0.;
for(int i=0;i<30;i++){
  vec3 p = ro+rd*d;
  float n = snoise3D(p*...);
  density += n*.1*(1.-density);
  d += .2;
}`,
        steps: [
          { title: 'Volume Raymarching', code: 'density += n*.1*(1.-density)', explanation: 'Accumulate density along ray. (1-density) prevents over-saturation - clouds don\'t get infinitely bright.' },
          { title: '3D Noise Sampling', code: 'snoise3D(p)', explanation: '3D noise creates true volumetric cloud shapes, not just 2D textures.' }
        ],
        concepts: [
          { icon: '‚òÅÔ∏è', name: 'Volume Rendering', desc: 'Accumulate along rays' },
          { icon: 'üé≤', name: '3D Noise', desc: 'True volumetric density' }
        ]
      },
      'grid': {
        name: 'Infinite Grid',
        author: '@XorDev',
        category: 'geometric',
        chars: 165,
        code: `vec2 uv = FC.xy/r.y;
uv += t*.1;
vec2 g = abs(fract(uv*10.)-.5);
float d = min(g.x,g.y);
float line = smoothstep(.02,.03,d);`,
        steps: [
          { title: 'Grid Creation', code: 'fract(uv*10.)-.5', explanation: 'fract() repeats 0-1, -.5 centers it. Now we have -0.5 to 0.5 in each cell.' },
          { title: 'Distance to Lines', code: 'min(g.x,g.y)', explanation: 'Distance to nearest grid line is minimum of X and Y distances. Closer = smaller value.' }
        ],
        concepts: [
          { icon: 'üìê', name: 'fract() Tiling', desc: 'Repeat pattern infinitely' },
          { icon: 'üìè', name: 'Line Distance', desc: 'min() for nearest axis' }
        ]
      },
      'hexagons': {
        name: 'Hexagonal Grid',
        author: '@XorDev',
        category: 'geometric',
        chars: 200,
        code: `vec2 h = vec2(1,1.732);  // 1 and sqrt(3)
vec2 a = mod(uv,h)-h*.5;
vec2 b = mod(uv-h*.5,h)-h*.5;
vec2 g = dot(a,a)<dot(b,b)?a:b;`,
        steps: [
          { title: 'Hex Ratio', code: 'vec2(1,1.732)', explanation: 'Hexagons have a height/width ratio of ‚àö3. This creates the proper hex proportions.' },
          { title: 'Dual Grid', code: 'dot(a,a)<dot(b,b)?a:b', explanation: 'Hexagonal tiling needs two offset grids. We pick whichever cell center is closer.' }
        ],
        concepts: [
          { icon: '‚¨°', name: 'Hex Geometry', desc: '60¬∞ angles, ‚àö3 ratio' },
          { icon: 'üîÄ', name: 'Offset Grids', desc: 'Two grids for hex tiling' }
        ]
      },
      'kaleidoscope': {
        name: 'Kaleidoscope',
        author: '@XorDev',
        category: 'geometric',
        chars: 175,
        code: `float a = atan(uv.y,uv.x);
float seg = 6.28/8.;
a = mod(a,seg)-seg*.5;
uv = vec2(cos(a),abs(sin(a)))*length(uv);`,
        steps: [
          { title: 'Angular Segments', code: 'mod(a,seg)-seg*.5', explanation: 'Divides the circle into 8 segments and wraps the angle into one segment.' },
          { title: 'Mirror Fold', code: 'abs(sin(a))', explanation: 'abs() mirrors half the segment, creating kaleidoscope symmetry.' }
        ],
        concepts: [
          { icon: 'üîÆ', name: 'Polar Folding', desc: 'mod() + abs() for symmetry' },
          { icon: '‚ú®', name: 'N-fold Symmetry', desc: '2œÄ/N for N segments' }
        ]
      },
      'warp': {
        name: 'Warp Drive',
        author: '@XorDev',
        category: 'psychedelic',
        chars: 160,
        code: `float a = atan(uv.y,uv.x)/6.28+.5;
float l = length(uv);
float n = snoise2D(vec2(a*20.,l*5.-t*2.))*l;
vec3 c = hsv(a+n*.2,1.,.9)*(1.-l);`,
        steps: [
          { title: 'Radial Noise', code: 'snoise2D(vec2(a*20.,l*5.-t*2.))', explanation: 'Noise sampled in polar coords creates radial streaks. The -t*2 makes them flow outward.' },
          { title: 'HSV Coloring', code: 'hsv(a+n*.2,1.,.9)', explanation: 'Hue based on angle creates rainbow, noise adds variation.' }
        ],
        concepts: [
          { icon: 'üåÄ', name: 'Polar Noise', desc: 'Noise in angle/radius space' },
          { icon: 'üé®', name: 'HSV', desc: 'Hue for rainbow colors' }
        ]
      },
      'pulse': {
        name: 'Neon Pulse',
        author: '@XorDev',
        category: 'psychedelic',
        chars: 170,
        code: `float d = length(uv);
float ring = abs(sin(d*10.-t*3.))*.5;
ring = pow(ring,3.);
float a = atan(uv.y,uv.x);
ring *= sin(a*5.+t)*.5+.5;`,
        steps: [
          { title: 'Expanding Rings', code: 'sin(d*10.-t*3.)', explanation: 'Sine of distance creates rings. -t makes them expand outward.' },
          { title: 'Sharp Edges', code: 'pow(ring,3.)', explanation: 'Power function sharpens the rings - soft sine becomes crisp neon lines.' }
        ],
        concepts: [
          { icon: 'üí´', name: 'Radial Waves', desc: 'sin(distance) for rings' },
          { icon: '‚ö°', name: 'pow() Sharpening', desc: 'Higher power = sharper edges' }
        ]
      },
      'trippy': {
        name: 'Trippy Spiral',
        author: '@XorDev',
        category: 'psychedelic',
        chars: 185,
        code: `float l = log(length(uv)+.001);
float s = sin(a*5.+l*10.+t*2.);
s += sin(a*3.-l*8.-t);
s += sin(a*7.+l*5.+t*.5);`,
        steps: [
          { title: 'Logarithmic Spiral', code: 'log(length(uv))', explanation: 'log() of distance creates spirals that curve forever inward - the classic psychedelic look.' },
          { title: 'Multi-frequency', code: 'sin(a*5.), sin(a*3.), sin(a*7.)', explanation: 'Multiple spiral frequencies create moir√© interference patterns.' }
        ],
        concepts: [
          { icon: 'üåÄ', name: 'Log Spiral', desc: 'log(r) for infinite spirals' },
          { icon: '„Ä∞Ô∏è', name: 'Moir√©', desc: 'Overlapping patterns interfere' }
        ]
      },
      'interference': {
        name: 'Interference',
        author: '@XorDev',
        category: 'psychedelic',
        chars: 155,
        code: `for(float i=0.;i<5.;i++){
  vec2 c = vec2(sin(t+i),cos(t*.7+i))*.5;
  v += sin(length(uv-c)*20.-t*3.);
}`,
        steps: [
          { title: 'Moving Centers', code: 'vec2(sin(t+i),cos(t*.7+i))', explanation: '5 wave sources moving in circles. Each creates expanding ripples.' },
          { title: 'Wave Superposition', code: 'v += sin(length(uv-c)*20.)', explanation: 'All waves add together. Where peaks align = bright. Where they cancel = dark.' }
        ],
        concepts: [
          { icon: 'üîä', name: 'Superposition', desc: 'Waves add constructively/destructively' },
          { icon: 'üéØ', name: 'Point Sources', desc: 'Circular waves from points' }
        ]
      },
      'ribbon': {
        name: 'Ribbon',
        author: '@XorDev',
        category: 'abstract',
        chars: 190,
        code: `for(float i=0.;i<20.;i++){
  float a = i/20.*6.28+t*.5;
  vec2 p = vec2(cos(a),sin(a*2.))*.5;
  d = min(d,length(uv-p)-.05);
}`,
        steps: [
          { title: 'Lissajous Curve', code: 'vec2(cos(a),sin(a*2.))', explanation: 'Different frequencies in X and Y (1:2 ratio) create figure-8 patterns - Lissajous figures!' },
          { title: 'Point Cloud', code: 'min(d,length(uv-p))', explanation: '20 circles along the curve, minimum distance creates smooth ribbon.' }
        ],
        concepts: [
          { icon: '‚àû', name: 'Lissajous', desc: 'sin/cos at different frequencies' },
          { icon: '‚ö™', name: 'Point Cloud SDF', desc: 'min() of many circles' }
        ]
      },
      'noise_flow': {
        name: 'Noise Flow',
        author: '@XorDev',
        category: 'abstract',
        chars: 185,
        code: `vec2 p = uv;
for(int i=0;i<5;i++){
  p += vec2(snoise2D(p+t*.2),snoise2D(p.yx+t*.2))*.3;
}
float n = snoise2D(p);`,
        steps: [
          { title: 'Domain Warping', code: 'p += vec2(snoise2D(p),...)', explanation: 'Use noise to offset coordinates, then sample noise again. Creates flowing, organic distortion!' },
          { title: 'Iterative Warping', code: 'for(int i=0;i<5;i++)', explanation: 'Multiple iterations compound the warping effect for more complex flow.' }
        ],
        concepts: [
          { icon: 'üí®', name: 'Domain Warping', desc: 'Distort coords with noise' },
          { icon: 'üîÑ', name: 'Feedback', desc: 'Iterative distortion' }
        ]
      },
      'voronoi': {
        name: 'Voronoi',
        author: '@XorDev',
        category: 'abstract',
        chars: 200,
        code: `float d = 1e9;
vec2 closest;
for(float i=0.;i<20.;i++){
  vec2 p = vec2(sin(i*12.34+t),cos(i*43.21+t*.7));
  float dist = length(uv-p);
  if(dist<d){d=dist;closest=p;}
}`,
        steps: [
          { title: 'Seed Points', code: 'vec2(sin(i*12.34),cos(i*43.21))', explanation: 'Random-looking but deterministic positions using big numbers in sin/cos.' },
          { title: 'Nearest Neighbor', code: 'if(dist<d){d=dist;closest=p;}', explanation: 'Track the closest point. Pixels colored by their nearest seed = Voronoi diagram!' }
        ],
        concepts: [
          { icon: 'üî∂', name: 'Voronoi', desc: 'Color by nearest seed point' },
          { icon: 'üé≤', name: 'Pseudo-random', desc: 'sin(i*big) for randomness' }
        ]
      }
    };
    
    // Merge all shaders
    Object.assign(EXPLAINED_SHADERS, BASIC_SHADERS);
    
    // ==========================================
    // WEBGL ENGINE (same as index.html)
    // ==========================================
    
    const NOISE_FUNCTIONS = `
      vec3 mod289v3(vec3 x){return x-floor(x*(1./289.))*289.;}
      vec4 mod289v4(vec4 x){return x-floor(x*(1./289.))*289.;}
      vec4 permute(vec4 x){return mod289v4(((x*34.)+1.)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}
      
      float snoise2D(vec2 v){
        const vec4 C=vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);
        vec2 i=floor(v+dot(v,C.yy));
        vec2 x0=v-i+dot(i,C.xx);
        vec2 i1=(x0.x>x0.y)?vec2(1,0):vec2(0,1);
        vec4 x12=x0.xyxy+C.xxzz;
        x12.xy-=i1;
        i=mod289v3(vec3(i,0.)).xy;
        vec3 p=permute(permute(i.y+vec3(0,i1.y,1.))+i.x+vec3(0,i1.x,1.));
        vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);
        m=m*m;m=m*m;
        vec3 x=2.*fract(p*C.www)-1.;
        vec3 h=abs(x)-.5;
        vec3 ox=floor(x+.5);
        vec3 a0=x-ox;
        m*=1.79284291400159-.85373472095314*(a0*a0+h*h);
        vec3 g;
        g.x=a0.x*x0.x+h.x*x0.y;
        g.yz=a0.yz*x12.xz+h.yz*x12.yw;
        return 130.*dot(m,g);
      }
      
      float snoise3D(vec3 v){
        const vec2 C=vec2(1./6.,1./3.);
        const vec4 D=vec4(0.,.5,1.,2.);
        vec3 i=floor(v+dot(v,C.yyy));
        vec3 x0=v-i+dot(i,C.xxx);
        vec3 g=step(x0.yzx,x0.xyz);
        vec3 l=1.-g;
        vec3 i1=min(g.xyz,l.zxy);
        vec3 i2=max(g.xyz,l.zxy);
        vec3 x1=x0-i1+C.xxx;
        vec3 x2=x0-i2+C.yyy;
        vec3 x3=x0-D.yyy;
        i=mod289v3(i);
        vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));
        float n_=.142857142857;
        vec3 ns=n_*D.wyz-D.xzx;
        vec4 j=p-49.*floor(p*ns.z*ns.z);
        vec4 x_=floor(j*ns.z);
        vec4 y_=floor(j-7.*x_);
        vec4 x=x_*ns.x+ns.yyyy;
        vec4 y=y_*ns.x+ns.yyyy;
        vec4 h=1.-abs(x)-abs(y);
        vec4 b0=vec4(x.xy,y.xy);
        vec4 b1=vec4(x.zw,y.zw);
        vec4 s0=floor(b0)*2.+1.;
        vec4 s1=floor(b1)*2.+1.;
        vec4 sh=-step(h,vec4(0.));
        vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;
        vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
        vec3 p0=vec3(a0.xy,h.x);
        vec3 p1=vec3(a0.zw,h.y);
        vec3 p2=vec3(a1.xy,h.z);
        vec3 p3=vec3(a1.zw,h.w);
        vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
        p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;
        vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);
        m=m*m;
        return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
      }
      
      vec3 hsv(float h,float s,float v){
        vec4 t=vec4(1.,2./3.,1./3.,3.);
        vec3 p=abs(fract(vec3(h)+t.xyz)*6.-vec3(t.w));
        return v*mix(vec3(t.x),clamp(p-vec3(t.x),0.,1.),s);
      }
      
      mat2 rotate2D(float a){
        return mat2(cos(a),sin(a),-sin(a),cos(a));
      }
    `;
    
    let gl, program, tLoc, rLoc;
    let animating = true;
    let startTime = Date.now();
    let animationId;
    
    function createShader(canvas, code) {
      gl = canvas.getContext('webgl');
      if (!gl) return false;
      
      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, 'attribute vec2 position;void main(){gl_Position=vec4(position,0,1);}');
      gl.compileShader(vs);
      
      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, `
        precision highp float;
        uniform float t;
        uniform vec2 r;
        #define FC gl_FragCoord
        ${NOISE_FUNCTIONS}
        void main(){
          vec4 o=vec4(0,0,0,1);
          ${code}
          gl_FragColor=o;
        }
      `);
      gl.compileShader(fs);
      
      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(fs));
        return false;
      }
      
      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      gl.useProgram(program);
      
      const vertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      
      const pos = gl.getAttribLocation(program, 'position');
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
      
      tLoc = gl.getUniformLocation(program, 't');
      rLoc = gl.getUniformLocation(program, 'r');
      
      return true;
    }
    
    function render() {
      if (!gl) return;
      const time = (Date.now() - startTime) / 1000;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(tLoc, time);
      gl.uniform2f(rLoc, gl.canvas.width, gl.canvas.height);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      if (animating) {
        animationId = requestAnimationFrame(render);
      }
    }
    
    // ==========================================
    // UI GENERATION
    // ==========================================
    
    function highlightCode(code) {
      return code
        .replace(/\b(float|vec2|vec3|vec4|mat2|mat3|int|void|for|if|break|return)\b/g, '<span class="keyword">$1</span>')
        .replace(/\b(sin|cos|tan|atan|length|normalize|dot|cross|mix|min|max|abs|fract|floor|mod|pow|exp|sqrt|smoothstep|step|snoise2D|snoise3D|hsv|tanh|log)\b/g, '<span class="function">$1</span>')
        .replace(/\b(\d+\.?\d*e?\d*)\b/g, '<span class="number">$1</span>')
        .replace(/(FC|gl_FragCoord|gl_FragColor)/g, '<span class="type">$1</span>')
        .replace(/\b([rto])\b(?=[\.\;\)\,\+\-\*\/])/g, '<span class="type">$1</span>')
        .replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
    }
    
    function renderExplanation(shader) {
      const content = document.getElementById('explanation-content');
      
      let html = `
        <div class="code-section">
          <h3 class="section-title">üíª Full Code</h3>
          <div class="code-block">
            <div class="code-header">
              <span>${shader.name} - ${shader.author}</span>
              <span>${shader.chars} chars</span>
            </div>
            <div class="code-content">
              <pre>${highlightCode(shader.code)}</pre>
            </div>
          </div>
        </div>
        
        <div class="code-section">
          <h3 class="section-title">üîç Step-by-Step Breakdown</h3>
      `;
      
      shader.steps.forEach((step, i) => {
        html += `
          <div class="step">
            <div class="step-number">${i + 1}</div>
            <div class="step-content">
              <div class="step-title">${step.title}</div>
              <div class="code-block">
                <div class="code-content">
                  <pre>${highlightCode(step.code)}</pre>
                </div>
              </div>
              <div class="annotation">
                <div class="annotation-content">${step.explanation}</div>
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      
      if (shader.concepts) {
        html += `
          <div class="code-section">
            <h3 class="section-title">üß† Key Concepts</h3>
            <div class="concept-grid">
        `;
        
        shader.concepts.forEach(concept => {
          html += `
            <div class="concept-card">
              <div class="concept-icon">${concept.icon}</div>
              <div class="concept-name">${concept.name}</div>
              <div class="concept-desc">${concept.desc}</div>
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      // Add coordinate system diagram for first few shaders
      if (['plasma', 'tunnel', 'matrix'].includes(shader.id)) {
        html += `
          <div class="code-section">
            <h3 class="section-title">üìê Coordinate System</h3>
            <div class="diagram">
              <div class="diagram-title">Fragment Coordinates (FC / gl_FragCoord)</div>
              <div class="coord-diagram">
                <div class="coord-grid">
                  <span class="coord-label coord-origin">(0,0)</span>
                  <span class="coord-label coord-x">X ‚Üí</span>
                  <span class="coord-label coord-y">Y ‚Üë</span>
                  <div class="pixel-dot" style="left: 75%; top: 25%;"></div>
                </div>
                <p style="font-size: 0.9rem; opacity: 0.7; text-align: center; max-width: 300px;">
                  Each pixel has coordinates (x, y). Bottom-left is (0,0). 
                  The shader runs once per pixel!
                </p>
              </div>
            </div>
          </div>
        `;
      }
      
      content.innerHTML = html;
    }
    
    function loadShader(id) {
      const shader = EXPLAINED_SHADERS[id];
      if (!shader) return;
      
      // Update UI
      document.getElementById('shader-title').textContent = shader.name;
      document.getElementById('char-count').textContent = shader.chars + ' chars';
      
      // Update URL hash
      history.replaceState(null, null, '#' + id);
      
      // Render explanation
      renderExplanation(shader);
      
      // Start shader
      cancelAnimationFrame(animationId);
      startTime = Date.now();
      animating = true;
      
      const canvas = document.getElementById('preview-canvas');
      if (createShader(canvas, shader.code)) {
        render();
      }
      
      // Update button states
      document.getElementById('play-btn').classList.add('active');
      document.getElementById('pause-btn').classList.remove('active');
    }
    
    // ==========================================
    // INITIALIZATION
    // ==========================================
    
    // Populate dropdown
    const dropdown = document.getElementById('shader-dropdown');
    dropdown.innerHTML = '';
    
    const categories = {};
    Object.entries(EXPLAINED_SHADERS).forEach(([id, shader]) => {
      if (!categories[shader.category]) categories[shader.category] = [];
      categories[shader.category].push({ id, ...shader });
    });
    
    Object.entries(categories).forEach(([category, shaders]) => {
      const group = document.createElement('optgroup');
      group.label = category.charAt(0).toUpperCase() + category.slice(1);
      shaders.forEach(shader => {
        const option = document.createElement('option');
        option.value = shader.id;
        option.textContent = shader.name;
        group.appendChild(option);
      });
      dropdown.appendChild(group);
    });
    
    dropdown.addEventListener('change', (e) => {
      if (e.target.value) loadShader(e.target.value);
    });
    
    // Controls
    document.getElementById('play-btn').addEventListener('click', () => {
      animating = true;
      document.getElementById('play-btn').classList.add('active');
      document.getElementById('pause-btn').classList.remove('active');
      render();
    });
    
    document.getElementById('pause-btn').addEventListener('click', () => {
      animating = false;
      cancelAnimationFrame(animationId);
      document.getElementById('play-btn').classList.remove('active');
      document.getElementById('pause-btn').classList.add('active');
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      startTime = Date.now();
    });
    
    // Load initial shader from URL hash or default
    const hash = window.location.hash.slice(1);
    const initialShader = EXPLAINED_SHADERS[hash] ? hash : 'plasma';
    dropdown.value = initialShader;
    loadShader(initialShader);
  </script>
</body>
</html>
