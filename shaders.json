[
  {
    "id": "plasma",
    "name": "Plasma",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float v = sin(u.x*10.+t) + sin(u.y*10.+t) + sin((u.x+u.y)*10.+t);\n  gl_FragColor = vec4(v/3.*.5+.5, v/3.*.2+.2, v/3.*.4+.6, 1.);\n}",
    "explanation": [
      {"line": "vec2 u = gl_FragCoord.xy / r;", "desc": "Normalize pixel coordinates to 0-1 range. gl_FragCoord gives the pixel position, dividing by resolution (r) maps it to UV coordinates."},
      {"line": "float v = sin(u.x*10.+t) + sin(u.y*10.+t) + sin((u.x+u.y)*10.+t);", "desc": "Sum of 3 sine waves: horizontal, vertical, and diagonal. The *10 controls frequency, +t animates over time. Classic plasma effect from the demoscene."},
      {"line": "gl_FragColor = vec4(v/3.*.5+.5, ...)", "desc": "Map the -3 to 3 range to colors. Divide by 3, multiply by 0.5, add 0.5 to get 0-1 range. Different multipliers per channel create the purple/pink palette."}
    ]
  },
  {
    "id": "noise",
    "name": "Fractal Noise",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nfloat noise(vec2 s) {\n  vec2 i = floor(s), f = fract(s);\n  float a = rand(i), b = rand(i+vec2(1,0)), c = rand(i+vec2(0,1)), d = rand(i+vec2(1,1));\n  vec2 u = f*f*(3.-2.*f);\n  return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n}\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float n = noise(u*5.+t*.3) + noise(u*10.-t*.2)*.5;\n  gl_FragColor = vec4(n*.2, n*.8, n, 1.);\n}",
    "explanation": [
      {"line": "float rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }", "desc": "Pseudo-random hash function. The magic numbers create chaotic output from any 2D input. fract() keeps it 0-1."},
      {"line": "vec2 i = floor(s), f = fract(s);", "desc": "Split coordinates into integer (grid cell) and fractional (position within cell) parts."},
      {"line": "vec2 u = f*f*(3.-2.*f);", "desc": "Smoothstep interpolation curve. Creates smooth transitions between random values instead of harsh edges."},
      {"line": "noise(u*5.+t*.3) + noise(u*10.-t*.2)*.5", "desc": "Fractal layering (octaves): add noise at different scales. Higher frequency = less amplitude. Creates organic, cloud-like patterns."}
    ]
  },
  {
    "id": "tunnel",
    "name": "Tunnel",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  float tun = 1./d + t;\n  float p = sin(a*8. + tun*2.) * sin(tun*4.) * smoothstep(0., .5, d);\n  gl_FragColor = vec4(p*.8+.2, p*.3, p*.6+.4, 1.);\n}",
    "explanation": [
      {"line": "vec2 u = (gl_FragCoord.xy - r*.5) / r.y;", "desc": "Center coordinates at screen middle, normalize by height for aspect-correct circles."},
      {"line": "float a = atan(u.y, u.x), d = length(u);", "desc": "Convert to polar coordinates: a = angle around center, d = distance from center."},
      {"line": "float tun = 1./d + t;", "desc": "The tunnel trick: 1/distance creates depth illusion. Adding time makes it scroll inward forever."},
      {"line": "sin(a*8. + tun*2.) * sin(tun*4.)", "desc": "Multiply two wave patterns: angular stripes (a*8) and radial rings (tun*4). Creates the tunnel texture."}
    ]
  },
  {
    "id": "rain",
    "name": "Matrix Rain",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r, g = floor(u * vec2(40.,25.));\n  float x = rand(g), d = fract(x*10. - t*(.5+x));\n  float b = smoothstep(1.,0.,d) * step(.8,x);\n  gl_FragColor = vec4(0., b, b*.3, 1.);\n}",
    "explanation": [
      {"line": "g = floor(u * vec2(40.,25.))", "desc": "Divide screen into 40x25 grid cells. Each cell is one potential raindrop column."},
      {"line": "float x = rand(g)", "desc": "Random value per cell. This determines both IF a drop exists and its timing offset."},
      {"line": "fract(x*10. - t*(.5+x))", "desc": "Animated drop position. x*10 offsets start time, t*(.5+x) varies speed per column. fract() loops 0-1."},
      {"line": "step(.8,x)", "desc": "Only show drops where random > 0.8 (20% of columns). Creates sparse rain effect."}
    ]
  },
  {
    "id": "warp",
    "name": "Warp",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x) + t*.5, d = length(u);\n  float w = sin(d*20. - t*3.) * sin(a*5.);\n  vec3 c = .5 + .5*cos(t + d*10. + vec3(0,2,4));\n  gl_FragColor = vec4(c * (w*.5+.5), 1.);\n}",
    "explanation": [
      {"line": "float a = atan(u.y, u.x) + t*.5", "desc": "Angle from center, slowly rotating over time. Creates the spinning motion."},
      {"line": "sin(d*20. - t*3.) * sin(a*5.)", "desc": "Radial waves (d*20) moving outward (-t*3) multiplied by 5 angular spokes. Classic warp pattern."},
      {"line": "vec3 c = .5 + .5*cos(t + d*10. + vec3(0,2,4))", "desc": "Rainbow palette trick: offset cosines by 0, 2, 4 radians create smooth RGB cycling. Distance adds spatial variation."}
    ]
  },
  {
    "id": "rings",
    "name": "Rings",
    "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float d = length(u);\n  float ring = sin(d*30. - t*2.) * sin(d*20. + t);\n  ring = smoothstep(0., .1, abs(ring));\n  vec3 c = mix(vec3(1., .2, .5), vec3(.2, .8, 1.), d);\n  gl_FragColor = vec4(c * ring, 1.);\n}",
    "explanation": [
      {"line": "float d = length(u);", "desc": "Distance from center. All rings are based on this single value."},
      {"line": "sin(d*30. - t*2.) * sin(d*20. + t)", "desc": "Two ring patterns at different frequencies, moving opposite directions. Multiplication creates interference/moir√©."},
      {"line": "smoothstep(0., .1, abs(ring))", "desc": "Convert smooth waves to sharp rings. abs() makes both peaks and troughs visible, smoothstep sharpens edges."},
      {"line": "mix(vec3(1., .2, .5), vec3(.2, .8, 1.), d)", "desc": "Gradient from pink (center) to cyan (edge) based on distance."}
    ]
  }
]
