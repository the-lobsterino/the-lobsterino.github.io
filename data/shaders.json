[
  {
    "id": "plasma",
    "name": "Plasma",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Start with UV coordinates",
        "desc": "Normalize pixel position to 0-1 range",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  gl_FragColor = vec4(u.x, u.y, 0., 1.);\n}"
      },
      {
        "title": "Add a horizontal sine wave",
        "desc": "sin(u.x * 10) creates vertical stripes that oscillate",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float v = sin(u.x * 10.);\n  gl_FragColor = vec4(v*.5+.5, 0., 0., 1.);\n}"
      },
      {
        "title": "Add time animation",
        "desc": "Adding +t makes the waves scroll over time",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float v = sin(u.x * 10. + t);\n  gl_FragColor = vec4(v*.5+.5, 0., 0., 1.);\n}"
      },
      {
        "title": "Layer multiple waves",
        "desc": "Add vertical + diagonal waves for interference patterns",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float v = sin(u.x*10.+t) + sin(u.y*10.+t) + sin((u.x+u.y)*10.+t);\n  v = v / 3. * .5 + .5;\n  gl_FragColor = vec4(v, v*.4, v*.8, 1.);\n}"
      },
      {
        "title": "Final: Color palette",
        "desc": "Adjust RGB channels for that classic plasma look",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float v = sin(u.x*10.+t) + sin(u.y*10.+t) + sin((u.x+u.y)*10.+t);\n  gl_FragColor = vec4(v/3.*.5+.5, v/3.*.2+.2, v/3.*.4+.6, 1.);\n}"
      }
    ]
  },
  {
    "id": "tunnel",
    "name": "Tunnel",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Center the coordinates",
        "desc": "Subtract half resolution to put (0,0) at screen center",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  gl_FragColor = vec4(u.x+.5, u.y+.5, 0., 1.);\n}"
      },
      {
        "title": "Convert to polar coordinates",
        "desc": "angle (atan) and distance (length) from center",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  gl_FragColor = vec4(a/6.28+.5, d, 0., 1.);\n}"
      },
      {
        "title": "The tunnel trick: 1/distance",
        "desc": "Inverting distance creates infinite depth illusion",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  float tun = 1./d;\n  gl_FragColor = vec4(fract(tun), fract(tun), fract(tun), 1.);\n}"
      },
      {
        "title": "Add animation",
        "desc": "Adding time makes you fly through the tunnel",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  float tun = 1./d + t;\n  gl_FragColor = vec4(fract(tun), fract(tun), fract(tun), 1.);\n}"
      },
      {
        "title": "Final: Add texture pattern",
        "desc": "Multiply angle stripes \u00d7 radial rings for tunnel walls",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  float tun = 1./d + t;\n  float p = sin(a*8. + tun*2.) * sin(tun*4.) * smoothstep(0., .5, d);\n  gl_FragColor = vec4(p*.8+.2, p*.3, p*.6+.4, 1.);\n}"
      }
    ]
  },
  {
    "id": "metaballs",
    "name": "Metaballs",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Single point glow",
        "desc": "1/distance creates a soft glow around a point",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float v = .2 / length(u);\n  gl_FragColor = vec4(v, v*.3, v*.5, 1.);\n}"
      },
      {
        "title": "Move the point",
        "desc": "Subtract a position to move the glow center",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  vec2 p = vec2(sin(t), cos(t)) * .5;\n  float v = .2 / length(u - p);\n  gl_FragColor = vec4(v, v*.3, v*.5, 1.);\n}"
      },
      {
        "title": "Add multiple balls",
        "desc": "Sum the glow from several moving points",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float v = 0.;\n  for(float i = 0.; i < 3.; i++) {\n    vec2 p = vec2(sin(t + i*2.), cos(t*.7 + i*2.)) * .5;\n    v += .1 / length(u - p);\n  }\n  gl_FragColor = vec4(v, v*.3, v*.5, 1.);\n}"
      },
      {
        "title": "Final: Threshold for blob edges",
        "desc": "smoothstep creates sharp edges where fields combine",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float v = 0.;\n  for(float i = 0.; i < 5.; i++) {\n    vec2 p = vec2(sin(t + i*1.3), cos(t*.7 + i*1.7)) * .5;\n    v += .1 / length(u - p);\n  }\n  v = smoothstep(.8, 1.2, v);\n  gl_FragColor = vec4(v * vec3(.8, .2, .5), 1.);\n}"
      }
    ]
  },
  {
    "id": "fractal",
    "name": "Julia Fractal",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Setup complex plane",
        "desc": "Map screen to complex number coordinates",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 z = (gl_FragCoord.xy*3. - r*1.5) / r.y;\n  gl_FragColor = vec4(z.x+.5, z.y+.5, .5, 1.);\n}"
      },
      {
        "title": "One iteration of z\u00b2 + c",
        "desc": "Complex squaring: (a+bi)\u00b2 = a\u00b2-b\u00b2 + 2abi",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 z = (gl_FragCoord.xy*3. - r*1.5) / r.y;\n  vec2 c = vec2(-.7, .3);\n  z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n  gl_FragColor = vec4(length(z)*.3, length(z)*.3, length(z)*.3, 1.);\n}"
      },
      {
        "title": "Iterate multiple times",
        "desc": "Repeat z\u00b2 + c and count iterations until escape",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 z = (gl_FragCoord.xy*3. - r*1.5) / r.y;\n  vec2 c = vec2(-.7, .3);\n  float i = 0.;\n  for(i = 0.; i < 50.; i++) {\n    z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n    if(length(z) > 2.) break;\n  }\n  float col = i / 50.;\n  gl_FragColor = vec4(col, col, col, 1.);\n}"
      },
      {
        "title": "Final: Animate + rainbow colors",
        "desc": "Vary c over time, map iterations to rainbow",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 z = (gl_FragCoord.xy*3. - r*1.5) / r.y;\n  float i = 0.;\n  for(i = 0.; i < 50.; i++) {\n    z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + vec2(-.7 + sin(t*.2)*.1, .3);\n    if(length(z) > 2.) break;\n  }\n  float c = i / 50.;\n  gl_FragColor = vec4(.5+.5*cos(c*6.+vec3(0,2,4)), 1.);\n}"
      }
    ]
  },
  {
    "id": "fire",
    "name": "Fire",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Create noise function",
        "desc": "Pseudo-random hash + interpolation = smooth noise",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nfloat noise(vec2 s) { vec2 i = floor(s), f = fract(s); vec2 u = f*f*(3.-2.*f);\n  return mix(mix(rand(i), rand(i+vec2(1,0)), u.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), u.x), u.y); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float n = noise(u * 10.);\n  gl_FragColor = vec4(n, n, n, 1.);\n}"
      },
      {
        "title": "Scroll noise upward",
        "desc": "Subtracting time from Y makes it rise like flames",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nfloat noise(vec2 s) { vec2 i = floor(s), f = fract(s); vec2 u = f*f*(3.-2.*f);\n  return mix(mix(rand(i), rand(i+vec2(1,0)), u.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), u.x), u.y); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float n = noise(vec2(u.x*5., u.y*3. - t*2.));\n  gl_FragColor = vec4(n, n, n, 1.);\n}"
      },
      {
        "title": "Add octaves + fade to top",
        "desc": "Layer noise frequencies, fade out at top like flames",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nfloat noise(vec2 s) { vec2 i = floor(s), f = fract(s); vec2 u = f*f*(3.-2.*f);\n  return mix(mix(rand(i), rand(i+vec2(1,0)), u.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), u.x), u.y); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float n = noise(vec2(u.x*5., u.y*3. - t*2.));\n  n += noise(vec2(u.x*10., u.y*6. - t*3.)) * .5;\n  n *= (1. - u.y);\n  gl_FragColor = vec4(n, n, n, 1.);\n}"
      },
      {
        "title": "Final: Fire color gradient",
        "desc": "R=linear, G=squared, B=cubed = orange-yellow-white",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nfloat noise(vec2 s) { vec2 i = floor(s), f = fract(s); vec2 u = f*f*(3.-2.*f);\n  return mix(mix(rand(i), rand(i+vec2(1,0)), u.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), u.x), u.y); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  float n = noise(vec2(u.x*5., u.y*3. - t*2.));\n  n += noise(vec2(u.x*10., u.y*6. - t*3.)) * .5;\n  n *= (1. - u.y);\n  gl_FragColor = vec4(n*1.5, n*n*.8, n*n*n*.3, 1.);\n}"
      }
    ]
  },
  {
    "id": "sphere",
    "name": "Lit Sphere",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Draw a circle",
        "desc": "Discard pixels outside radius 1",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float d = length(u);\n  if(d > 1.) { gl_FragColor = vec4(0,0,0,1); return; }\n  gl_FragColor = vec4(.3, .5, .8, 1.);\n}"
      },
      {
        "title": "Calculate sphere normal",
        "desc": "Z component from Pythagorean theorem: z = \u221a(1-x\u00b2-y\u00b2)",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float d = length(u);\n  if(d > 1.) { gl_FragColor = vec4(0,0,0,1); return; }\n  vec3 n = vec3(u, sqrt(1. - d*d));\n  gl_FragColor = vec4(n*.5+.5, 1.);\n}"
      },
      {
        "title": "Add diffuse lighting",
        "desc": "dot(normal, light) = how much surface faces the light",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float d = length(u);\n  if(d > 1.) { gl_FragColor = vec4(0,0,0,1); return; }\n  vec3 n = vec3(u, sqrt(1. - d*d));\n  vec3 l = normalize(vec3(1., .5, 1.));\n  float diff = max(dot(n, l), 0.);\n  gl_FragColor = vec4(vec3(.2,.4,.8)*diff, 1.);\n}"
      },
      {
        "title": "Final: Rotating light + specular",
        "desc": "Animate light direction, add shiny highlight",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy*2. - r) / r.y;\n  float d = length(u);\n  if(d > 1.) { gl_FragColor = vec4(0,0,0,1); return; }\n  vec3 n = vec3(u, sqrt(1. - d*d));\n  vec3 l = normalize(vec3(sin(t), .5, cos(t)));\n  float diff = max(dot(n, l), 0.);\n  float spec = pow(max(dot(reflect(-l, n), vec3(0,0,1)), 0.), 32.);\n  gl_FragColor = vec4(vec3(.2,.4,.8)*diff + spec, 1.);\n}"
      }
    ]
  },
  {
    "id": "warp",
    "name": "Rainbow Warp",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Polar coordinates",
        "desc": "Get angle and distance from center",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  gl_FragColor = vec4(a/6.28+.5, d, 0., 1.);\n}"
      },
      {
        "title": "Create warp pattern",
        "desc": "Radial waves \u00d7 angular spokes",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x), d = length(u);\n  float w = sin(d*20.) * sin(a*5.);\n  gl_FragColor = vec4(w*.5+.5, w*.5+.5, w*.5+.5, 1.);\n}"
      },
      {
        "title": "Animate rotation + waves",
        "desc": "Add time to angle and radial pattern",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x) + t*.5, d = length(u);\n  float w = sin(d*20. - t*3.) * sin(a*5.);\n  gl_FragColor = vec4(w*.5+.5, w*.5+.5, w*.5+.5, 1.);\n}"
      },
      {
        "title": "Final: Rainbow colors",
        "desc": "Phase-offset cosines create smooth RGB cycling",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = (gl_FragCoord.xy - r*.5) / r.y;\n  float a = atan(u.y, u.x) + t*.5, d = length(u);\n  float w = sin(d*20. - t*3.) * sin(a*5.);\n  vec3 c = .5 + .5*cos(t + d*10. + vec3(0,2,4));\n  gl_FragColor = vec4(c * (w*.5+.5), 1.);\n}"
      }
    ]
  },
  {
    "id": "rain",
    "name": "Matrix Rain",
    "author": "@XorDev",
    "link": "https://twitter.com/XorDev",
    "steps": [
      {
        "title": "Create grid cells",
        "desc": "Divide screen into columns and rows",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  vec2 g = floor(u * vec2(40., 25.));\n  gl_FragColor = vec4(fract(g.x*.1), fract(g.y*.1), 0., 1.);\n}"
      },
      {
        "title": "Random value per cell",
        "desc": "Hash function gives unique random per column",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  vec2 g = floor(u * vec2(40., 25.));\n  float x = rand(g);\n  gl_FragColor = vec4(x, x, x, 1.);\n}"
      },
      {
        "title": "Animate drops falling",
        "desc": "fract(random - time) creates looping animation",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r;\n  vec2 g = floor(u * vec2(40., 25.));\n  float x = rand(g);\n  float d = fract(x*10. - t*(.5+x));\n  gl_FragColor = vec4(0., d, d*.3, 1.);\n}"
      },
      {
        "title": "Final: Sparse drops + fade",
        "desc": "Only some columns rain, smoothstep for glow trail",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nfloat rand(vec2 s) { return fract(sin(dot(s, vec2(12.9898,78.233))) * 43758.5453); }\nvoid main() {\n  vec2 u = gl_FragCoord.xy / r, g = floor(u * vec2(40.,25.));\n  float x = rand(g), d = fract(x*10. - t*(.5+x));\n  float b = smoothstep(1.,0.,d) * step(.8,x);\n  gl_FragColor = vec4(0., b, b*.3, 1.);\n}"
      }
    ]
  },
  {
    "id": "xor-electro",
    "name": "Electro",
    "author": "@XorDev",
    "link": "https://x.com/XorDev/status/2011848145680974024",
    "steps": [
      {
        "title": "Center coordinates",
        "desc": "Map screen to -1 to 1 range",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y;\n  gl_FragColor = vec4(p.x*.5+.5, p.y*.5+.5, 0., 1.);\n}"
      },
      {
        "title": "Create lens distortion",
        "desc": "d = 0.9 - dot(p,p) creates a circular falloff",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y;\n  float d = .9 - dot(p, p);\n  gl_FragColor = vec4(d, d, d, 1.);\n}"
      },
      {
        "title": "Final: Electric pattern",
        "desc": "tan() creates sharp electric lines, animated with time",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y;\n  float d = .9 - dot(p, p);\n  vec4 o = tanh(.3 / abs(tan(p.y * sqrt(max(d, -d * .1) / .3) + p.x + t + vec4(6., 0., 9., 0.))));\n  gl_FragColor = vec4(o.rgb, 1.);\n}"
      }
    ]
  },
  {
    "id": "xor-scatter",
    "name": "Scatter",
    "author": "@XorDev",
    "link": "https://x.com/XorDev/status/2001739376204697905",
    "steps": [
      {
        "title": "Centered coordinates with noise",
        "desc": "Add slight randomness per pixel",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (2. * gl_FragCoord.xy - r) / r.y;\n  p += .02 / fract(dot(gl_FragCoord.xy, sin(gl_FragCoord.yxyx)).xy);\n  gl_FragColor = vec4(p.x*.5+.5, p.y*.5+.5, 0., 1.);\n}"
      },
      {
        "title": "Final: Diamond frame",
        "desc": "max(abs(x),abs(y)) creates diamond, colors from position",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (2. * gl_FragCoord.xy - r) / r.y + .02 / fract(dot(gl_FragCoord.xy, sin(gl_FragCoord.yxyx)).xy);\n  vec4 o = tanh((p.xyyx + p.xxyx + 1.) * .01 / abs(max(abs(p.x), abs(p.y)) - .5));\n  gl_FragColor = vec4(o.rgb, 1.);\n}"
      }
    ]
  },
  {
    "id": "xor-rocaille",
    "name": "Rocaille",
    "author": "@XorDev",
    "link": "https://x.com/XorDev/status/2015809381665812862",
    "steps": [
      {
        "title": "Setup and scale",
        "desc": "Center coords, scale by 0.3",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y / .3;\n  gl_FragColor = vec4(fract(p.x), fract(p.y), 0., 1.);\n}"
      },
      {
        "title": "Nested loop iteration",
        "desc": "Inner loop warps v with sin waves",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y / .3, v;\n  for(float f = 0.; f < 9.; f++) v = p + sin(v.yx * f + t) / f;\n  gl_FragColor = vec4(v.x*.5+.5, v.y*.5+.5, .5, 1.);\n}"
      },
      {
        "title": "Final: Layered colors",
        "desc": "Outer loop adds rainbow colors based on distance",
        "code": "precision mediump float; uniform float t; uniform vec2 r;\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2. - r) / r.y / .3, v;\n  vec4 o = vec4(0.);\n  for(float i = 0.; i < 10.; i++) {\n    v = p;\n    for(float f = 0.; f < 9.; f++) v += sin(v.yx * f + i + t) / f;\n    o += (cos(i + vec4(0., 1., 2., 3.)) + 1.) / 6. / length(v);\n  }\n  gl_FragColor = vec4(tanh(o * o).rgb, 1.);\n}"
      }
    ]
  }
]